---
interface Props {
  galleryItems: string[];
  interval?: number;
}

const { galleryItems, interval = 8000 } = Astro.props as Props;

// Dividi
---

<div
  class="relative w-full hero-carousel flex flex-col justify-center items-center gap-[50px]"
  data-interval={interval}
>
  <!-- Viewport -->
  <div class="overflow-x-hidden w-full h-full">
    <div
      class="flex flex-nowrap transition-transform duration-800 ease-in-out hero-carousel-track h-full w-full"
    >
      {
        galleryItems.map((items) => (
          <div class="shrink-0 w-full md:w-1/2 lg:w-1/3 px-2 h-60 relative">
            {/* Slide content */}
            {/* Cada slide con <section> y fondo de imagen */}
            <section class="w-full h-full flex items-center justify-center relative">
              <img
                src={`/${items}.webp`}
                alt="Slide image"
                width="394"
                height="20"
                loading="lazy"
                decoding="async"
                class="absolute inset-0 w-full h-full object-cover z-20 object-center rounded-[15px]"
              />
            </section>
          </div>
        ))
      }
    </div>
  </div>

  <!-- Controles con barra de progreso y botones -->
  <div class="w-full flex justify-center items-center gap-6 px-1">
    <div class="flex-1 flex items-center gap-4">
      <div class="flex-1 bg-[#C0C0C0] rounded-full h-2 backdrop-blur-sm">
        <div
          class="hero-carousel-progress bg-accent-3 h-2 rounded-full transition-all duration-500 ease-out"
          style="width: 33.33%"
        >
        </div>
      </div>
    </div>
    <!-- Botón anterior -->
    <button
      class="hero-carousel-prev border border-accent-3 text-accent-3 py-2 px-4 rounded-xl transition-all duration-200"
      aria-label="Previous slide"
    >
      <svg
        class="w-5 h-5"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M15 19l-7-7 7-7"></path>
      </svg>
    </button>

    <!-- Barra de progreso -->

    <!-- Botón siguiente -->
    <button
      class="hero-carousel-next hero-carousel-prev border border-accent-3 text-accent-3 py-2 px-4 rounded-xl transition-all duration-200"
      aria-label="Next slide"
    >
      <svg
        class="w-5 h-5"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M9 5l7 7-7 7"></path>
      </svg>
    </button>
  </div>
</div>

<script is:inline>
  (function () {
    if (typeof window === 'undefined') return;

    // Función simple para generar un hash (para IDs únicos)
    String.prototype.hashCode = function () {
      let hash = 0;
      for (let i = 0; i < this.length; i++) {
        const char = this.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
      }
      return Math.abs(hash);
    };

    const debounce = (fn, ms = 100) => {
      let t;
      return (...a) => {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(this, a), ms);
      };
    };

    function initCarousel(carousel) {
      if (!carousel || carousel.dataset.inited) return;
      carousel.dataset.inited = '1';

      const track = carousel.querySelector('.hero-carousel-track');
      const prevBtn = carousel.querySelector('.hero-carousel-prev');
      const nextBtn = carousel.querySelector('.hero-carousel-next');
      const progressBar = carousel.querySelector('.hero-carousel-progress');
      const counter = carousel.querySelector('.hero-carousel-counter');
      const total = carousel.querySelector('.hero-carousel-total');

      const intervalMs =
        parseInt(carousel.getAttribute('data-interval') || '0', 10) || 5000;

      let slides = Array.from(track.children);
      const totalSlides = slides.length;

      // Actualizar el contador total
      if (total && totalSlides > 0) {
        total.textContent = totalSlides.toString();
      }

      const setup = () => {
        // helper to detect items per view
        function getItemsPerView() {
          const w = window.innerWidth;
          if (w >= 1024) return 3; // lg and up -> 3 visible (this carousel uses 3-per-slide)
          if (w >= 768) return 2; // md -> 2 visible
          return 1; // sm -> 1 visible
        }

        // clear any previous auto interval stored on the carousel (when re-running setup)
        if (carousel._heroAuto) {
          clearInterval(carousel._heroAuto);
          carousel._heroAuto = null;
        }

        // recompute responsive values
        let itemsPerView = getItemsPerView();
        // For the testimonial carousel we want overlapping slides on lg: advance by 1 when showing 3
        let step = itemsPerView >= 3 ? 1 : itemsPerView;

        // Keep originals (non-clone) and remove previous clones
        const originals = Array.from(track.children).filter(
          (n) => !n.classList.contains('clone')
        );
        // remove any existing clones
        Array.from(track.querySelectorAll('.clone')).forEach((n) => n.remove());

        // If there is only one original slide, nothing to clone
        if (originals.length <= 1) {
          slides = Array.from(track.children);
        } else {
          const cloneCount = itemsPerView;

          // prepend clones of the last `cloneCount` originals
          for (
            let i = Math.max(0, originals.length - cloneCount);
            i < originals.length;
            i++
          ) {
            const c = originals[i].cloneNode(true);
            c.classList.add('clone');
            track.insertBefore(c, track.firstChild);
          }

          // append clones of the first `cloneCount` originals
          for (let i = 0; i < Math.min(cloneCount, originals.length); i++) {
            const c = originals[i].cloneNode(true);
            c.classList.add('clone');
            track.appendChild(c);
          }

          slides = Array.from(track.children);
        }

        let currentIndex = itemsPerView; // start at first real slide after prepended clones
        let isTransitioning = false;
        let autoSlide;

        // itemsPerView and step are declared above and updated in updateProgress when needed

        function getSlideWidth() {
          return slides[0].getBoundingClientRect().width;
        }

        function updateProgress() {
          if (slides.length <= 1) return;

          // realSlideCount is the number of original slides (without clones)
          const realSlideCount = Array.from(track.children).filter(
            (n) => !n.classList.contains('clone')
          ).length;

          // Recompute itemsPerView and step in case of resize
          itemsPerView = getItemsPerView();
          step = itemsPerView >= 3 ? 1 : itemsPerView;

          // Compute realIndex (0-based in originals)
          const cloneCount = itemsPerView;
          let realIndex =
            (currentIndex - cloneCount + realSlideCount) % realSlideCount;

          // total number of paging positions
          const totalPositions = Math.max(1, Math.ceil(realSlideCount / step));

          let position = Math.floor(realIndex / step);
          position = Math.max(0, Math.min(position, totalPositions - 1));

          const progressPercentage = ((position + 1) / totalPositions) * 100;

          if (progressBar) {
            progressBar.style.width = `${progressPercentage}%`;
          }

          if (counter) {
            counter.textContent = (position + 1).toString();
          }
        }

        function goTo(index, smooth = true) {
          if (slides.length <= 1) return;

          const maxIndex = slides.length - 1;
          if (index < 0) index = 0;
          if (index > maxIndex) index = maxIndex;

          if (isTransitioning && smooth) return;
          track.style.transition = smooth
            ? 'transform 0.5s ease-in-out'
            : 'none';
          track.style.transform = `translateX(-${getSlideWidth() * index}px)`;
          currentIndex = index;
          isTransitioning = smooth;
          updateProgress();
        }

        if (slides.length > 1) {
          track.addEventListener('transitionend', () => {
            const originalsCount = Array.from(track.children).filter(
              (n) => !n.classList.contains('clone')
            ).length;
            const cloneCount = itemsPerView;

            // if we've moved into the clones at the end, jump back to the equivalent original
            if (currentIndex >= originalsCount + cloneCount) {
              currentIndex = currentIndex - originalsCount;
              track.style.transition = 'none';
              track.style.transform = `translateX(-${getSlideWidth() * currentIndex}px)`;
            }

            // if we've moved into the clones at the start, jump forward to equivalent original
            if (currentIndex < cloneCount) {
              currentIndex = currentIndex + originalsCount;
              track.style.transition = 'none';
              track.style.transform = `translateX(-${getSlideWidth() * currentIndex}px)`;
            }

            isTransitioning = false;
          });
        }

        prevBtn?.addEventListener('click', () => {
          // move by step on large screens, otherwise by itemsPerView (full page)
          goTo(currentIndex - step);
          resetAuto();
        });

        nextBtn?.addEventListener('click', () => {
          goTo(currentIndex + step);
          resetAuto();
        });

        function startAuto() {
          if (slides.length > 1) {
            carousel._heroAuto = setInterval(
              () => goTo(currentIndex + step),
              intervalMs
            );
          }
        }

        function stopAuto() {
          if (carousel._heroAuto) {
            clearInterval(carousel._heroAuto);
            carousel._heroAuto = null;
          }
        }

        function resetAuto() {
          stopAuto();
          startAuto();
        }

        carousel.addEventListener('mouseenter', stopAuto, { passive: true });
        carousel.addEventListener('mouseleave', startAuto, { passive: true });

        // Touch support
        let startX = 0,
          deltaX = 0;

        track.addEventListener(
          'touchstart',
          (e) => {
            startX = e.touches[0].clientX;
            stopAuto();
          },
          { passive: true }
        );

        track.addEventListener(
          'touchend',
          (e) => {
            deltaX = e.changedTouches[0].clientX - startX;
            if (Math.abs(deltaX) > 50) {
              const dir = deltaX < 0 ? 1 : -1;
              goTo(currentIndex + dir * step);
            }
            resetAuto();
          },
          { passive: true }
        );

        // Mouse drag support
        let isDragging = false;
        let dragStartX = 0;
        let dragDelta = 0;

        function onMouseMove(e) {
          if (!isDragging) return;
          dragDelta = e.clientX - dragStartX;
          const translate = -getSlideWidth() * currentIndex + dragDelta;
          track.style.transform = `translateX(${translate}px)`;
        }

        function onMouseUp() {
          if (!isDragging) return;
          isDragging = false;
          window.removeEventListener('mousemove', onMouseMove);
          window.removeEventListener('mouseup', onMouseUp);
          if (Math.abs(dragDelta) > 50) {
            const dir = dragDelta < 0 ? 1 : -1;
            goTo(currentIndex + dir * step);
          } else {
            goTo(currentIndex, true);
          }
          dragDelta = 0;
          resetAuto();
        }

        track.addEventListener('mousedown', (e) => {
          if (e.button !== 0) return;
          isDragging = true;
          dragStartX = e.clientX;
          dragDelta = 0;
          stopAuto();
          track.style.transition = 'none';
          window.addEventListener('mousemove', onMouseMove);
          window.addEventListener('mouseup', onMouseUp);
          e.preventDefault();
        });

        function init() {
          slides = Array.from(track.children);
          if (slides.length > 1) {
            goTo(currentIndex, false);
          }
          updateProgress();
        }

        // On resize re-run setup to rebuild clones for the new itemsPerView
        window.addEventListener(
          'resize',
          debounce(() => setup(), 120)
        );

        init();
        startAuto();
      };

      if ('requestIdleCallback' in window)
        requestIdleCallback(setup, { timeout: 1500 });
      else setTimeout(setup, 600);
    }

    const carousels = Array.from(
      document.querySelectorAll('.hero-carousel[data-interval]')
    );
    if (carousels.length === 0) return;

    if ('IntersectionObserver' in window) {
      const io = new IntersectionObserver(
        (entries, obs) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              initCarousel(entry.target);
              obs.unobserve(entry.target);
            }
          });
        },
        { root: null, rootMargin: '400px' }
      );
      carousels.forEach((c) => io.observe(c));
    } else {
      carousels.forEach((c) => initCarousel(c));
    }
  })();
</script>

<style>
  .hero-carousel-progress {
    background: linear-gradient(90deg, #E6007E 0%, #E6007E 100%);
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
  }

  .hero-carousel-prev:hover,
  .hero-carousel-next:hover {
    transform: scale(1.1);
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.4);
  }
</style>

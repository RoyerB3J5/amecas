---
interface GalleryItem {
  imgSrc: string;
  name: string;
}

interface Props {
  galleryItems: GalleryItem[];
  interval?: number;
}

const { galleryItems, interval = 8000 } = Astro.props as Props;

// Render each gallery item as its own slide; grouping is handled client-side
// (responsive grouping: lg=6, sm..lg=4, xs=2)
---

<div
  class="relative w-full hero-carousel flex flex-col justify-center items-center gap-[50px]"
  data-interval={interval}
>
  <!-- Viewport -->
  <div class="overflow-x-hidden w-full h-full">
    <div
      class="flex flex-nowrap transition-transform duration-800 ease-in-out hero-carousel-track h-full w-full"
    >
      {
        galleryItems.map((item: GalleryItem, index: number) => (
          <div class="gallery-item flex justify-center p-2 relative overflow-hidden ">
            <div class="relative w-full max-w-[387px] h-[187px] flex items-center justify-center">
              <svg
                viewBox="0 0 387 187"
                width="100%"
                xmlns="http://www.w3.org/2000/svg"
                class="w-full h-full"
              >
                <defs>
                  <clipPath id={`wavyClip-${index}`}>
                    <path d="M0 187C0.900685 181.273 3.07163 175.772 6.45794 171.091C12.0723 163.33 14.4876 153.111 12.9537 143.254C10.7992 129.41 16.3223 115.479 26.9174 108.032L27.7573 107.441C35.336 102.115 40.5395 93.4084 42.0653 83.5026C44.2036 69.6221 53.4653 58.4956 65.6367 55.1854L66.8724 54.8499C75.6512 52.4623 83.1545 46.0804 87.5901 37.2293C93.8236 24.7906 105.912 17.559 118.564 18.7003L119.579 18.7913C128.689 19.6131 137.705 16.232 144.555 9.42461C154.247 -0.20748 168.175 -2.65158 180.094 2.99552C188.584 7.01856 198.415 7.01856 206.906 2.99552C218.825 -2.65159 232.753 -0.20749 242.445 9.42461C249.295 16.232 258.311 19.6131 267.421 18.7913L268.436 18.7003C281.088 17.559 293.176 24.7905 299.41 37.2293C303.845 46.0803 311.349 52.4623 320.128 54.8499L321.363 55.1853C333.535 58.4956 342.796 69.6221 344.935 83.5026C346.46 93.4084 351.664 102.115 359.243 107.441L360.083 108.032C370.678 115.479 376.201 129.41 374.046 143.254C372.512 153.111 374.928 163.33 380.542 171.091C383.928 175.772 386.099 181.273 387 187L0 187Z" />
                  </clipPath>
                </defs>
                <g clip-path={`url(#wavyClip-${index})`}>
                  <image
                    href={item.imgSrc}
                    width="387"
                    height="187"
                    preserveAspectRatio="xMidYMid slice"
                  />
                  <rect
                    x="0"
                    y="0"
                    width="387"
                    height="187"
                    fill="black"
                    fill-opacity="0.4"
                  />
                  <text
                    x="50%"
                    y="60%"
                    text-anchor="middle"
                    dominant-baseline="middle"
                    fill="white"
                    font-size="22"
                    font-weight="bold"
                    style="paint-order:stroke fill; text-shadow: 0 2px 8px #0008; letter-spacing: 1px; text-transform: uppercase;"
                  >
                    {(item.name || '').toUpperCase()}
                  </text>
                </g>
              </svg>
            </div>
          </div>
        ))
      }
    </div>
  </div>

  <!-- Controles con barra de progreso y botones -->
  <div class="w-full flex justify-center items-center gap-6 px-1">
    <div class="flex-1 flex items-center gap-4">
      <div class="flex-1 bg-[#C0C0C0] rounded-full h-2 backdrop-blur-sm">
        <div
          class="hero-carousel-progress bg-accent-3 h-2 rounded-full transition-all duration-500 ease-out"
          style="width: 0%"
        >
        </div>
      </div>
    </div>
    <!-- Botón anterior -->
    <button
      class="hero-carousel-prev border border-accent-3 text-accent-3 py-2 px-4 rounded-xl transition-all duration-200"
      aria-label="Previous slide"
    >
      <svg
        class="w-5 h-5"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M15 19l-7-7 7-7"></path>
      </svg>
    </button>

    <!-- Barra de progreso -->

    <!-- Botón siguiente -->
    <button
      class="hero-carousel-next hero-carousel-prev border border-accent-3 text-accent-3 py-2 px-4 rounded-xl transition-all duration-200"
      aria-label="Next slide"
    >
      <svg
        class="w-5 h-5"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M9 5l7 7-7 7"></path>
      </svg>
    </button>
  </div>
</div>

<script is:inline>
  (function () {
    if (typeof window === 'undefined') return;

    // Función simple para generar un hash (para IDs únicos)
    String.prototype.hashCode = function () {
      let hash = 0;
      for (let i = 0; i < this.length; i++) {
        const char = this.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
      }
      return Math.abs(hash);
    };

    const debounce = (fn, ms = 100) => {
      let t;
      return (...a) => {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(this, a), ms);
      };
    };

    function initCarousel(carousel) {
      if (!carousel || carousel.dataset.inited) return;
      carousel.dataset.inited = '1';

      const track = carousel.querySelector('.hero-carousel-track');
      const prevBtn = carousel.querySelector('.hero-carousel-prev');
      const nextBtn = carousel.querySelector('.hero-carousel-next');
      const progressBar = carousel.querySelector('.hero-carousel-progress');
      const counter = carousel.querySelector('.hero-carousel-counter');
      const total = carousel.querySelector('.hero-carousel-total');

      const intervalMs =
        parseInt(carousel.getAttribute('data-interval') || '0', 10) || 5000;

      let slides = Array.from(track.children);
      const totalSlides = slides.length;

      // Actualizar el contador total
      if (total && totalSlides > 0) {
        total.textContent = totalSlides.toString();
      }

      const setup = () => {
        function getItemsPerView() {
          const w = window.innerWidth;
          if (w >= 1024) return 6; // lg and up -> 6 per slide
          if (w >= 640) return 4; // sm..lg -> 4 per slide
          return 2; // xs -> 2 per slide
        }

        // cleanup previous auto
        if (carousel._heroAuto) {
          clearInterval(carousel._heroAuto);
          carousel._heroAuto = null;
        }

        // gather item nodes
        const itemNodes = Array.from(track.querySelectorAll('.gallery-item'));

        if (itemNodes.length === 0) return;

        // remove everything from track (we'll rebuild slides)
        track.innerHTML = '';

        const itemsPerView = getItemsPerView();

        // build slides: each slide contains up to itemsPerView items and uses the original grid layout
        const slidesBuilt = [];
        for (let i = 0; i < itemNodes.length; i += itemsPerView) {
          const slide = document.createElement('div');
          slide.className =
            'shrink-0 w-full h-full flex items-center justify-center relative';

          const inner = document.createElement('div');
          inner.className = 'w-full max-w-[1200px] mx-auto';

          const grid = document.createElement('div');
          grid.className =
            'grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-[50px] w-full';

          const chunk = itemNodes.slice(i, i + itemsPerView);
          chunk.forEach((n) => {
            // ensure the item is styled correctly inside grid
            n.classList.remove('shrink-0');
            grid.appendChild(n);
          });

          inner.appendChild(grid);
          slide.appendChild(inner);
          track.appendChild(slide);
          slidesBuilt.push(slide);
        }

        // now slides are the direct children of track
        slides = Array.from(track.children);

        // clone first and last for infinite wrap
        if (slides.length > 1) {
          const firstClone = slides[0].cloneNode(true);
          const lastClone = slides[slides.length - 1].cloneNode(true);
          firstClone.classList.add('clone');
          lastClone.classList.add('clone');
          track.appendChild(firstClone);
          track.insertBefore(lastClone, track.firstChild);
          slides = Array.from(track.children);
        }

        let currentIndex = slides.length > 1 ? 1 : 0;
        let isTransitioning = false;

        function getSlideWidth() {
          return slides[0].getBoundingClientRect().width;
        }

        function updateProgress() {
          if (slides.length <= 1) return;
          const realSlides = slides.filter(
            (s) => !s.classList.contains('clone')
          ).length;
          let realIndex = currentIndex - 1;
          if (currentIndex === 0) realIndex = realSlides - 1;
          else if (currentIndex === slides.length - 1) realIndex = 0;
          const progressPercentage = ((realIndex + 1) / realSlides) * 100;
          if (progressBar) progressBar.style.width = `${progressPercentage}%`;
        }

        function goTo(index, smooth = true) {
          if (slides.length <= 1) return;
          const maxIndex = slides.length - 1;
          if (index < 0) index = 0;
          if (index > maxIndex) index = maxIndex;
          if (isTransitioning && smooth) return;
          track.style.transition = smooth
            ? 'transform 0.5s ease-in-out'
            : 'none';
          track.style.transform = `translateX(-${getSlideWidth() * index}px)`;
          currentIndex = index;
          isTransitioning = smooth;
          updateProgress();
        }

        if (carousel._onTrans)
          track.removeEventListener('transitionend', carousel._onTrans);
        const onTrans = () => {
          const realSlides = slides.filter(
            (s) => !s.classList.contains('clone')
          ).length;
          if (slides[currentIndex] === slides[0]) {
            // jumped to prepended clone -> move to last real
            currentIndex = realSlides;
            track.style.transition = 'none';
            track.style.transform = `translateX(-${getSlideWidth() * currentIndex}px)`;
          }
          if (slides[currentIndex] === slides[slides.length - 1]) {
            // jumped to appended clone -> move to first real
            currentIndex = 1;
            track.style.transition = 'none';
            track.style.transform = `translateX(-${getSlideWidth() * currentIndex}px)`;
          }
          isTransitioning = false;
        };
        carousel._onTrans = onTrans;
        track.addEventListener('transitionend', onTrans);

        if (carousel._prevHandler && prevBtn)
          prevBtn.removeEventListener('click', carousel._prevHandler);
        if (carousel._nextHandler && nextBtn)
          nextBtn.removeEventListener('click', carousel._nextHandler);

        carousel._prevHandler = () => {
          goTo(currentIndex - 1);
          resetAuto();
        };
        carousel._nextHandler = () => {
          goTo(currentIndex + 1);
          resetAuto();
        };
        prevBtn?.addEventListener('click', carousel._prevHandler);
        nextBtn?.addEventListener('click', carousel._nextHandler);

        function startAuto() {
          if (slides.length > 1) {
            carousel._heroAuto = setInterval(
              () => goTo(currentIndex + 1),
              intervalMs
            );
          }
        }

        function stopAuto() {
          if (carousel._heroAuto) {
            clearInterval(carousel._heroAuto);
            carousel._heroAuto = null;
          }
        }

        function resetAuto() {
          stopAuto();
          startAuto();
        }

        // touch
        if (carousel._touchStart && track)
          track.removeEventListener('touchstart', carousel._touchStart);
        if (carousel._touchEnd && track)
          track.removeEventListener('touchend', carousel._touchEnd);
        let startX = 0,
          deltaX = 0;
        carousel._touchStart = (e) => {
          startX = e.touches[0].clientX;
          stopAuto();
        };
        carousel._touchEnd = (e) => {
          deltaX = e.changedTouches[0].clientX - startX;
          if (Math.abs(deltaX) > 50) {
            const dir = deltaX < 0 ? 1 : -1;
            goTo(currentIndex + dir);
          }
          resetAuto();
        };
        track.addEventListener('touchstart', carousel._touchStart, {
          passive: true,
        });
        track.addEventListener('touchend', carousel._touchEnd, {
          passive: true,
        });

        // mouse drag
        if (carousel._mouseMove)
          window.removeEventListener('mousemove', carousel._mouseMove);
        if (carousel._mouseUp)
          window.removeEventListener('mouseup', carousel._mouseUp);
        let isDragging = false,
          dragStartX = 0,
          dragDelta = 0;
        carousel._mouseMove = (e) => {
          if (!isDragging) return;
          dragDelta = e.clientX - dragStartX;
          const translate = -getSlideWidth() * currentIndex + dragDelta;
          track.style.transform = `translateX(${translate}px)`;
        };
        carousel._mouseUp = () => {
          if (!isDragging) return;
          isDragging = false;
          window.removeEventListener('mousemove', carousel._mouseMove);
          window.removeEventListener('mouseup', carousel._mouseUp);
          if (Math.abs(dragDelta) > 50) {
            const dir = dragDelta < 0 ? 1 : -1;
            goTo(currentIndex + dir);
          } else {
            goTo(currentIndex, true);
          }
          dragDelta = 0;
          resetAuto();
        };
        track.addEventListener('mousedown', (e) => {
          if (e.button !== 0) return;
          isDragging = true;
          dragStartX = e.clientX;
          dragDelta = 0;
          stopAuto();
          track.style.transition = 'none';
          window.addEventListener('mousemove', carousel._mouseMove);
          window.addEventListener('mouseup', carousel._mouseUp);
          e.preventDefault();
        });

        function init() {
          slides = Array.from(track.children);
          if (slides.length > 1) goTo(currentIndex, false);
          updateProgress();
        }

        // rebuild on resize
        if (!carousel._resizeAdded) {
          window.addEventListener(
            'resize',
            debounce(() => setup(), 120)
          );
          carousel._resizeAdded = true;
        }

        init();
        startAuto();
      };

      if ('requestIdleCallback' in window)
        requestIdleCallback(setup, { timeout: 1500 });
      else setTimeout(setup, 600);
    }

    const carousels = Array.from(
      document.querySelectorAll('.hero-carousel[data-interval]')
    );
    if (carousels.length === 0) return;

    if ('IntersectionObserver' in window) {
      const io = new IntersectionObserver(
        (entries, obs) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              initCarousel(entry.target);
              obs.unobserve(entry.target);
            }
          });
        },
        { root: null, rootMargin: '400px' }
      );
      carousels.forEach((c) => io.observe(c));
    } else {
      carousels.forEach((c) => initCarousel(c));
    }
  })();
</script>

<style>
  .hero-carousel-progress {
    background: linear-gradient(90deg, #e6007e 0%, #e6007e 100%);
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
  }

  .hero-carousel-prev:hover,
  .hero-carousel-next:hover {
    transform: scale(1.1);
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.4);
  }
</style>

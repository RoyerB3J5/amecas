---
import Button from './Button.astro';

interface slide {
  image: string;
  text: string;
  title: string;
  button: string;
}
interface Props {
  items: slide[];
  interval?: number;
}

const { items, interval = 8000 } = Astro.props as Props;
---

<div
  class="relative w-full hero-carousel"
  data-interval={interval}
>
  <!-- Viewport -->
  <div class="overflow-x-hidden w-full h-full">
    <div
      class="flex flex-nowrap transition-transform duration-800 ease-in-out hero-carousel-track h-full w-full"
    >
      {
        items.map((slide) => (
          <div
            class={`${slide.image} shrink-0 w-full h-full min-h-[637px] flex items-center justify-center relative`}
          >
            <div class="h-full w-full max-w-screen md:max-w-[1211px] flex justify-start items-center translate-y-4 lg:translate-y-8 px-5 xl:px-0">
              <div class="flex flex-col justify-center items-start gap-6">
                <p class="text-[19px] leading-[120%] font-medium uppercase text-white">
                  {slide.text}
                </p>
                <h1
                  class="text-[76px] leading-[78%] text-white"
                  set:html={slide.title}
                />
                <Button
                  text={slide.button}
                  extraBtnClass="border border-white px-6"
                  textClass="text-[13px] uppercase text-white"
                  iconClass=" text-white"
                />
              </div>
            </div>
          </div>
        ))
      }
    </div>
  </div>
  <div
    class="w-full max-w-screen md:w-[1211px] absolute bottom-[116px] lg:bottom-[100px] left-1/2 transform -translate-x-1/2 flex justify-start items-center px-6 xl:px-0"
  >
    <div class="flex gap-4 justify-center hero-carousel-indicators">
      {
        Array.from({ length: items.length }).map((_, i) => (
          <button
            class="flex justify-center items-center gap-2"
            data-index={i}
            aria-label={`Go to slide ${i + 1}`}
            aria-current={i === 0 ? 'true' : 'false'}
          >
            {/* Single-bar indicator: large when active, small when inactive */}
            <div
              class={
                i === 0
                  ? 'w-[52px] h-1.5 bg-white rounded-md transition-all duration-200'
                  : 'w-3.5 h-1.5 bg-white/50 rounded-md transition-all duration-200'
              }
            />
          </button>
        ))
      }
    </div>
  </div>
</div>

<script is:inline>
  (function () {
    if (typeof window === 'undefined') return;

    const debounce = (fn, ms = 100) => {
      let t;
      return (...a) => {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(this, a), ms);
      };
    };

    function initCarousel(carousel) {
      if (!carousel || carousel.dataset.inited) return;
      carousel.dataset.inited = '1';

      const track = carousel.querySelector('.hero-carousel-track');
      const prevBtn = carousel.querySelector('.hero-carousel-prev');
      const nextBtn = carousel.querySelector('.hero-carousel-next');
      const indicators = Array.from(
        carousel.querySelectorAll('.hero-carousel-indicators button')
      );
      const intervalMs =
        parseInt(carousel.getAttribute('data-interval') || '0', 10) || 5000;

      // Número real de slides (sin clones)
      let slides = Array.from(track.children);

      // Heavy setup (clones/listeners) deferred to idle to avoid blocking main load
      const setup = () => {
        const firstClone = slides[0].cloneNode(true);
        const lastClone = slides[slides.length - 1].cloneNode(true);
        track.appendChild(firstClone);
        track.insertBefore(lastClone, track.firstChild);
        slides = Array.from(track.children); // ahora con clones

        let currentIndex = 1;
        let isTransitioning = false;
        let autoSlide;

        // Force one slide per page (we render each slide as full width)
        function getPerPage() {
          return 1;
        }

        function getSlideWidth() {
          return slides[0].getBoundingClientRect().width;
        }

        function goTo(index, smooth = true) {
          // clamp index to valid range
          const maxIndex = slides.length - 1;
          if (index < 0) index = 0;
          if (index > maxIndex) index = maxIndex;
          if (isTransitioning && smooth) return;
          track.style.transition = smooth
            ? 'transform 0.5s ease-in-out'
            : 'none';
          track.style.transform = `translateX(-${getSlideWidth() * index}px)`;
          currentIndex = index;
          isTransitioning = smooth;
        }

        function updateIndicators() {
          let realIndex = currentIndex - 1;
          if (currentIndex === 0) realIndex = slides.length - 3;
          else if (currentIndex === slides.length - 1) realIndex = 0;
          indicators.forEach((btn, i) => {
            const bar = btn.children[0];
            if (i === realIndex) {
              if (bar) {
                bar.classList.remove('w-3.5', 'bg-white/50');
                bar.classList.add('w-[52px]', 'bg-white');
              }
              btn.setAttribute('aria-current', 'true');
            } else {
              if (bar) {
                bar.classList.remove('w-[52px]', 'bg-white');
                bar.classList.add('w-3.5', 'bg-white/50');
              }
              btn.removeAttribute('aria-current');
            }
          });
        }

        track.addEventListener('transitionend', () => {
          if (slides[currentIndex] === firstClone) goTo(1, false);
          if (slides[currentIndex] === lastClone)
            goTo(slides.length - 2, false);
          isTransitioning = false;
          updateIndicators();
        });

        prevBtn?.addEventListener('click', () => {
          goTo(currentIndex - getPerPage());
          resetAuto();
        });
        nextBtn?.addEventListener('click', () => {
          goTo(currentIndex + getPerPage());
          resetAuto();
        });

        indicators.forEach((btn) =>
          btn.addEventListener('click', () => {
            const idx = Number(btn.dataset.index) + 1;
            goTo(idx);
            resetAuto();
          })
        );

        function startAuto() {
          autoSlide = setInterval(
            () => goTo(currentIndex + getPerPage()),
            intervalMs
          );
        }
        function stopAuto() {
          clearInterval(autoSlide);
        }
        function resetAuto() {
          stopAuto();
          startAuto();
        }

        carousel.addEventListener('mouseenter', stopAuto, { passive: true });
        carousel.addEventListener('mouseleave', startAuto, { passive: true });

        let startX = 0,
          deltaX = 0;

        // Touch support (mobile)
        track.addEventListener(
          'touchstart',
          (e) => {
            startX = e.touches[0].clientX;
            stopAuto();
          },
          { passive: true }
        );
        track.addEventListener(
          'touchend',
          (e) => {
            deltaX = e.changedTouches[0].clientX - startX;
            if (Math.abs(deltaX) > 50) {
              const dir = deltaX < 0 ? 1 : -1;
              goTo(currentIndex + dir * getPerPage());
            }
            resetAuto();
          },
          { passive: true }
        );

        // Mouse drag support (desktop) — allow click+drag to change slides
        let isDragging = false;
        let dragStartX = 0;
        let dragDelta = 0;

        function onMouseMove(e) {
          if (!isDragging) return;
          dragDelta = e.clientX - dragStartX;
          // move track according to drag delta
          const translate = -getSlideWidth() * currentIndex + dragDelta;
          track.style.transform = `translateX(${translate}px)`;
        }

        function onMouseUp() {
          if (!isDragging) return;
          isDragging = false;
          window.removeEventListener('mousemove', onMouseMove);
          window.removeEventListener('mouseup', onMouseUp);
          if (Math.abs(dragDelta) > 50) {
            const dir = dragDelta < 0 ? 1 : -1;
            goTo(currentIndex + dir * getPerPage());
          } else {
            // snap back
            goTo(currentIndex, true);
          }
          dragDelta = 0;
          resetAuto();
        }

        track.addEventListener('mousedown', (e) => {
          // left button only
          if (e.button !== 0) return;
          isDragging = true;
          dragStartX = e.clientX;
          dragDelta = 0;
          stopAuto();
          // disable transition while dragging
          track.style.transition = 'none';
          window.addEventListener('mousemove', onMouseMove);
          window.addEventListener('mouseup', onMouseUp);
          e.preventDefault();
        });

        function init() {
          slides = Array.from(track.children);
          goTo(1, false);
          updateIndicators();
        }
        window.addEventListener(
          'resize',
          debounce(() => init(), 120)
        );

        init();
        startAuto();
      };

      if ('requestIdleCallback' in window)
        requestIdleCallback(setup, { timeout: 1500 });
      else setTimeout(setup, 600);
    }

    // Observe carousels and init when visible
    const carousels = Array.from(
      document.querySelectorAll('.hero-carousel[data-interval]')
    );
    if (carousels.length === 0) return;

    if ('IntersectionObserver' in window) {
      const io = new IntersectionObserver(
        (entries, obs) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              initCarousel(entry.target);
              obs.unobserve(entry.target);
            }
          });
        },
        { root: null, rootMargin: '400px' }
      );
      carousels.forEach((c) => io.observe(c));
    } else {
      carousels.forEach((c) => initCarousel(c));
    }
  })();
</script>

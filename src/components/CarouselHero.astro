---
import { Icon } from 'astro-icon/components';
import Button from './Button.astro';

interface slide {
  image: string;
  text: string;
  title: string;
  button: string;
  href: string;
}
interface Props {
  items: slide[];
  interval?: number;
}

const { items, interval = 8000 } = Astro.props as Props;
---

<div class="relative w-full hero-carousel" data-interval={interval}>
  <!-- Viewport -->
  <div class="overflow-x-hidden w-full">
    <div
      class="flex flex-nowrap transition-transform duration-800 ease-in-out hero-carousel-track w-full min-h-[676px]"
    >
      {
        items.map((slide) => (
          <div class="flex flex-col justify-center items-center w-full relative shrink-0">
            <div
              class={`shrink-0 w-full h-auto min-h-[676px] flex items-center justify-center relative`}
            >
              <img
                src={`/bg-main.webp`}
                alt="Imagen de Fondo de Los Amecas"
                width="1512"
                height="727"
                class="absolute inset-0 w-full h-full object-cover -z-10 opacity-50"
                loading="lazy"
                decoding="async"
              />
              <div class="absolute inset-0 bg-accent-3 -z-20" />
              <div class="h-full w-full max-w-screen md:max-w-[1211px] flex justify-between items-center translate-y-4 lg:translate-y-8 px-5 xl:px-0">
                <div class="flex flex-col justify-center items-start gap-6">
                  <p class="text-[22px] leading-[120%] font-medium uppercase text-white tracking-[3.1px] ">
                    {slide.text}
                  </p>
                  <h1
                    class="text-[60px] lg:text-[70px] font-extrabold leading-[90%] text-white uppercase"
                    set:html={slide.title}
                  />
                  <Button
                    text={slide.button}
                    extraBtnClass="border border-white px-6"
                    textClass="text-[13px] uppercase text-white"
                    iconClass=" text-white"
                    href={slide.href}
                  />
                </div>
                <img
                  src={`/${slide.image}.webp`}
                  alt="Imagen decorativa"
                  width="600"
                  height="485"
                  class={`hidden sm:block w-[350px] lg:w-[400px] xl:w-[600px]  ${slide.image == 'hero-3' ? 'img-slide' : ''} ${slide.image == 'hero-2' ? 'img-slide-2 translate-y-20' : 'translate-y-10'} h-auto translate-y-10`}
                />
              </div>
            </div>
            <div class="w-full">
              <div class="w-full aspect-[1511.61/53.951996]">
                <Icon
                  name={'fondo-menu'}
                  class={'w-full h-full block'}
                  style="--fondo-color:#E6007E; --wave-color:#8BCE2B; --dots-color:#F4AA02;--svg-bg:#E5DECC"
                />
              </div>
            </div>
          </div>
        ))
      }
    </div>
  </div>
  <div
    class="w-full max-w-screen md:w-[1211px] absolute bottom-[116px] xl:bottom-[150px] left-1/2 transform -translate-x-1/2 flex justify-start items-center px-6 xl:px-0"
  >
    <div class="flex gap-4 justify-center hero-carousel-indicators">
      {
        Array.from({ length: items.length }).map((_, i) => (
          <button
            class="flex justify-center items-center gap-2"
            data-index={i}
            aria-label={`Go to slide ${i + 1}`}
            aria-current={i === 0 ? 'true' : 'false'}
          >
            {/* Single-bar indicator: large when active, small when inactive */}
            <div
              class={
                i === 0
                  ? 'w-[52px] h-1.5 bg-white rounded-md transition-all duration-200'
                  : 'w-3.5 h-1.5 bg-white/50 rounded-md transition-all duration-200'
              }
            />
          </button>
        ))
      }
    </div>
  </div>
</div>

<script is:inline>
  (function () {
    if (typeof window === 'undefined') return;

    const debounce = (fn, ms = 100) => {
      let t;
      return (...a) => {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(this, a), ms);
      };
    };

    function initCarousel(carousel) {
      if (!carousel || carousel.dataset.inited) return;
      carousel.dataset.inited = '1';

      const track = carousel.querySelector('.hero-carousel-track');
      const prevBtn = carousel.querySelector('.hero-carousel-prev');
      const nextBtn = carousel.querySelector('.hero-carousel-next');
      const indicators = Array.from(
        carousel.querySelectorAll('.hero-carousel-indicators button')
      );
      const intervalMs =
        parseInt(carousel.getAttribute('data-interval') || '0', 10) || 5000;

      // Número real de slides (sin clones)
      let slides = Array.from(track.children);

      // Heavy setup (clones/listeners) deferred to idle to avoid blocking main load
      const setup = () => {
        const firstClone = slides[0].cloneNode(true);
        const lastClone = slides[slides.length - 1].cloneNode(true);
        track.appendChild(firstClone);
        track.insertBefore(lastClone, track.firstChild);
        slides = Array.from(track.children); // ahora con clones

        let currentIndex = 1;
        let isTransitioning = false;
        let autoSlide;
        let pendingIndex = null;
        let rafId = null;

        // Force one slide per page (we render each slide as full width)
        function getPerPage() {
          return 1;
        }

        function getSlideWidth() {
          // Use the carousel container width as the authoritative slide width.
          // Fallback to the first slide or track if needed (images may still be loading).
          const w =
            carousel.getBoundingClientRect().width ||
            slides[0]?.getBoundingClientRect().width ||
            track.getBoundingClientRect().width;
          return w || 0;
        }

        function goTo(index, smooth = true) {
          // clamp index to valid range
          const maxIndex = slides.length - 1;
          if (index < 0) index = 0;
          if (index > maxIndex) index = maxIndex;
          // If a transition is ongoing, enqueue the request instead of dropping it
          if (isTransitioning && smooth) {
            pendingIndex = index;
            return;
          }
          track.style.transition = smooth
            ? 'transform 0.5s ease-in-out'
            : 'none';
          track.style.transform = `translateX(-${getSlideWidth() * index}px)`;
          currentIndex = index;
          isTransitioning = smooth;
          // Keep indicators in sync immediately (so they reflect the intended slide)
          try {
            updateIndicators();
          } catch (e) {
            // defensive: if updateIndicators isn't available yet, ignore
          }
        }

        function updateIndicators() {
          // Determine the index currently visible by reading the track's transform
          const style = getComputedStyle(track).transform;
          let indexFromTransform = currentIndex;
          if (style && style !== 'none') {
            const m = style.match(/matrix(?:3d)?\((.+)\)/);
            if (m && m[1]) {
              const parts = m[1].split(',').map((p) => p.trim());
              // matrix(a, b, c, d, tx, ty) -> tx is at position 4
              const tx = parseFloat(parts[4] ?? parts[12] ?? '0') || 0;
              const slideW = getSlideWidth() || 1;
              // tx is negative when the track is translated left; compute index accordingly
              indexFromTransform = Math.round(-tx / slideW);
              indexFromTransform = Math.max(
                0,
                Math.min(indexFromTransform, slides.length - 1)
              );
            }
          }

          let realIndex = indexFromTransform - 1;
          if (indexFromTransform === 0) realIndex = slides.length - 3;
          else if (indexFromTransform === slides.length - 1) realIndex = 0;

          indicators.forEach((btn, i) => {
            const bar = btn.children[0];
            if (i === realIndex) {
              if (bar) {
                bar.classList.remove('w-3.5', 'bg-white/50');
                bar.classList.add('w-[52px]', 'bg-white');
              }
              btn.setAttribute('aria-current', 'true');
            } else {
              if (bar) {
                bar.classList.remove('w-[52px]', 'bg-white');
                bar.classList.add('w-3.5', 'bg-white/50');
              }
              btn.removeAttribute('aria-current');
            }
          });
        }

        track.addEventListener('transitionend', () => {
          if (slides[currentIndex] === firstClone) goTo(1, false);
          if (slides[currentIndex] === lastClone)
            goTo(slides.length - 2, false);
          isTransitioning = false;
          updateIndicators();
          // If there was a pending goTo while the previous transition was running,
          // perform it now (this ensures user/auto requests are not lost).
          if (pendingIndex !== null) {
            const idx = pendingIndex;
            pendingIndex = null;
            // use a microtask to avoid re-entrancy inside transitionend handler
            Promise.resolve().then(() => goTo(idx, true));
          }
        });

        prevBtn?.addEventListener('click', () => {
          goTo(currentIndex - getPerPage());
          resetAuto();
        });
        nextBtn?.addEventListener('click', () => {
          goTo(currentIndex + getPerPage());
          resetAuto();
        });

        indicators.forEach((btn) =>
          btn.addEventListener('click', () => {
            const idx = Number(btn.dataset.index) + 1;
            goTo(idx);
            resetAuto();
          })
        );

        function startAuto() {
          // Ensure we don't create multiple intervals
          stopAuto();
          autoSlide = setInterval(
            () => goTo(currentIndex + getPerPage()),
            intervalMs
          );
        }
        function stopAuto() {
          if (autoSlide) clearInterval(autoSlide);
          autoSlide = null;
        }
        function resetAuto() {
          stopAuto();
          startAuto();
        }

        carousel.addEventListener('mouseenter', stopAuto, { passive: true });
        carousel.addEventListener('mouseleave', startAuto, { passive: true });

        let startX = 0,
          deltaX = 0;

        // Touch support (mobile)
        track.addEventListener(
          'touchstart',
          (e) => {
            startX = e.touches[0].clientX;
            stopAuto();
          },
          { passive: true }
        );
        // touchmove: mirror mouse drag behaviour to update transform and indicators
        track.addEventListener(
          'touchmove',
          (e) => {
            if (!e.touches || e.touches.length === 0) return;
            const touchX = e.touches[0].clientX;
            deltaX = touchX - startX;
            const translateTouch = -getSlideWidth() * currentIndex + deltaX;
            track.style.transform = `translateX(${translateTouch}px)`;
            if (!rafId) {
              rafId = requestAnimationFrame(() => {
                try {
                  updateIndicators();
                } finally {
                  rafId = null;
                }
              });
            }
          },
          { passive: true }
        );
        track.addEventListener(
          'touchend',
          (e) => {
            deltaX = e.changedTouches[0].clientX - startX;
            if (Math.abs(deltaX) > 50) {
              const dir = deltaX < 0 ? 1 : -1;
              goTo(currentIndex + dir * getPerPage());
            } else {
              // snap back to current
              goTo(currentIndex, true);
            }
            // cancel any pending rAF
            if (rafId) {
              cancelAnimationFrame(rafId);
              rafId = null;
            }
            resetAuto();
          },
          { passive: true }
        );

        // Mouse drag support (desktop) — allow click+drag to change slides
        let isDragging = false;
        let dragStartX = 0;
        let dragDelta = 0;

        function onMouseMove(e) {
          if (!isDragging) return;
          dragDelta = e.clientX - dragStartX;
          // move track according to drag delta
          const translate = -getSlideWidth() * currentIndex + dragDelta;
          track.style.transform = `translateX(${translate}px)`;
          // update indicators smoothly while dragging (throttled via rAF)
          if (!rafId) {
            rafId = requestAnimationFrame(() => {
              try {
                updateIndicators();
              } finally {
                rafId = null;
              }
            });
          }
        }

        function onMouseUp() {
          if (!isDragging) return;
          isDragging = false;
          window.removeEventListener('mousemove', onMouseMove);
          window.removeEventListener('mouseup', onMouseUp);
          if (Math.abs(dragDelta) > 50) {
            const dir = dragDelta < 0 ? 1 : -1;
            goTo(currentIndex + dir * getPerPage());
          } else {
            // snap back
            goTo(currentIndex, true);
          }
          dragDelta = 0;
          // cancel any pending rAF
          if (rafId) {
            cancelAnimationFrame(rafId);
            rafId = null;
          }
          resetAuto();
        }

        track.addEventListener('mousedown', (e) => {
          // left button only
          if (e.button !== 0) return;
          isDragging = true;
          dragStartX = e.clientX;
          dragDelta = 0;
          stopAuto();
          // disable transition while dragging
          track.style.transition = 'none';
          window.addEventListener('mousemove', onMouseMove);
          window.addEventListener('mouseup', onMouseUp);
          e.preventDefault();
        });

        function init() {
          slides = Array.from(track.children);
          goTo(1, false);
          updateIndicators();
          // restart autoplay safely when layout changes (e.g., resize)
          resetAuto();
        }
        window.addEventListener(
          'resize',
          debounce(() => init(), 120)
        );

        init();
        startAuto();
      };

      if ('requestIdleCallback' in window)
        requestIdleCallback(setup, { timeout: 1500 });
      else setTimeout(setup, 600);
    }

    // Observe carousels and init when visible
    const carousels = Array.from(
      document.querySelectorAll('.hero-carousel[data-interval]')
    );
    if (carousels.length === 0) return;

    if ('IntersectionObserver' in window) {
      const io = new IntersectionObserver(
        (entries, obs) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              initCarousel(entry.target);
              obs.unobserve(entry.target);
            }
          });
        },
        { root: null, rootMargin: '400px' }
      );
      carousels.forEach((c) => io.observe(c));
    } else {
      carousels.forEach((c) => initCarousel(c));
    }
  })();
</script>
